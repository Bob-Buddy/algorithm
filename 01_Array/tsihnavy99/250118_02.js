const { testEx } = require("../example");
// 제목: 배열 제어하기
// 풀이:
const solution = (arr) => {
  const set = new Set(arr); // 중복 데이터 제거 -> O(n) (배열 순회하며 Set에 추가)

  return Array.from(set).sort((a, b) => b - a); // 배열화, 역순 정렬 // 배열변환: O(n), sort: O(nlogn)
};

testEx(2, solution);

// 왜 이렇게 풀었나요?
/*
  중복 데이터를 허용하지 않는 Set을 사용하면
  직접 순회하는 로직을 구현하지 않고 빠르게
  문제를 해결할 수 있을 것이라 생각했습니다
  또한 sort에 비교함수를 추가하면 역순으로
  정렬하는 로직도 간단하게 구현 가능해
  sort를 사용했습니다

  JS에서 제공하는 메서드에 익숙해지려는 목적도 있지만
  문제에서 다른 조건이나 제한을 두지 않았기 때문에
  기존에 JS에서 제공하는 내장 객체나 메서드만
  활용해도 충분하다 생각했습니다

  + 250118
  Set을 사용하는 것이 코드상으로 간결하지만
  시간복잡도상으로는 효율적이지 못한지 찾아본 결과
  데이터를 순회하며 중복값을 비교(includes)하며 배열에 넣는 방법은 O(n²)
  key-value 형태로 저장해 비교하는 방법은 Set과 동일한 O(n)으로
  비슷한 성능을 갖지만 단순히 유니크한 값을 관리할 때는
  Set이 메모리 측면에서 더 효율적이라고 합니다
  또한 이 문제의 경우에는 sort가 가장 큰 연산(O(nlogn))이기 때문에
  다른 방식보다는 Set을 사용하는 것이 가장 효율적이라고 생각합니다
*/
